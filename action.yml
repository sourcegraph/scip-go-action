---
name: Sourcegraph Go SCIP Indexer
description: Generate SCIP data from Go source code
author: Sourcegraph
branding:
  icon: code
  color: orange

inputs:
  # scip-go inputs
  recursive:
    description: Recursively scan for go.mod files, indexing each identified project independently
    default: "true"
  go-mod-name:
    description: Specifies the name of the module defined by go-mod-root
    required: false
  go-mod-root:
    description: Specifies the directory containing the go.mod file
    required: false
  go-mod-version:
    description: Specifies the version of the module defined by go-mod-root
    required: false
  output:
    description: Output file path for the SCIP index
    default: index.scip
  project-root:
    description: Specifies the directory to index
    default: .
  quiet:
    description: Do not output to stdout or stderr
    default: "false"
  repository-remote:
    description: Specifies the canonical name of the repository remote
    required: false
  repository-root:
    description: Specifies the top-level directory of the git repository
    required: false
  scip-go-version:
    description: Version of scip-go to use (e.g., "v0.1.26", "latest")
    default: latest
  skip-implementations:
    description: Skip generating implementations
    default: "false"
  skip-tests:
    description: Skip compiling tests. Will not generate SCIP indexes over tests.
    default: "false"
  verbose:
    description: Verbosity level (0=default, 1=verbose, 2=very verbose, 3=very very verbose)
    default: "0"

  # src-cli inputs
  github-token:
    description: GitHub access token with 'public_repo' scope for repository verification when lsif.enforceAuth is enabled
    required: false
  sourcegraph-token:
    description: Sourcegraph access token for uploading indexes
    required: false
  sourcegraph-url:
    description: URL of the Sourcegraph instance (e.g., https://sourcegraph.com)
    required: false
  src-cli-version:
    description: Version of src-cli to use for uploads (e.g., "6.12.0", "latest")
    default: latest
  upload:
    description: Upload the index to a Sourcegraph instance
    default: "false"

outputs:
  index-path:
    description: Path to the generated SCIP index file(s), comma-separated when recursive
    value: ${{ steps.scip-go.outputs.index-path }}

runs:
  using: composite
  steps:
    - name: Install scip-go
      shell: bash
      env:
        SCIP_GO_VERSION: ${{ inputs.scip-go-version }}
      run: |
        set -euo pipefail
        echo "Installing scip-go@${SCIP_GO_VERSION}..."
        go install "github.com/sourcegraph/scip-go/cmd/scip-go@${SCIP_GO_VERSION}"
        echo "scip-go installed successfully"
        scip-go --version || true

    - name: Run scip-go
      id: scip-go
      shell: bash
      working-directory: ${{ inputs.project-root }}
      env:
        INPUT_RECURSIVE: ${{ inputs.recursive }}
        INPUT_OUTPUT: ${{ inputs.output }}
        INPUT_MODULE_ROOT: ${{ inputs.go-mod-root }}
        INPUT_MODULE_NAME: ${{ inputs.go-mod-name }}
        INPUT_MODULE_VERSION: ${{ inputs.go-mod-version }}
        INPUT_REPOSITORY_ROOT: ${{ inputs.repository-root }}
        INPUT_REPOSITORY_REMOTE: ${{ inputs.repository-remote }}
        INPUT_QUIET: ${{ inputs.quiet }}
        INPUT_VERBOSE: ${{ inputs.verbose }}
        INPUT_SKIP_IMPLEMENTATIONS: ${{ inputs.skip-implementations }}
        INPUT_SKIP_TESTS: ${{ inputs.skip-tests }}
        INPUT_PROJECT_ROOT: ${{ inputs.project-root }}
      run: |
        set -euo pipefail

        COMMON_ARGS=()
        [ -n "$INPUT_REPOSITORY_ROOT" ] && COMMON_ARGS+=("--repository-root=$INPUT_REPOSITORY_ROOT")
        [ -n "$INPUT_REPOSITORY_REMOTE" ] && COMMON_ARGS+=("--repository-remote=$INPUT_REPOSITORY_REMOTE")
        [ "$INPUT_QUIET" = "true" ] && COMMON_ARGS+=("--quiet")
        [ "$INPUT_SKIP_IMPLEMENTATIONS" = "true" ] && COMMON_ARGS+=("--skip-implementations")
        [ "$INPUT_SKIP_TESTS" = "true" ] && COMMON_ARGS+=("--skip-tests")
        for ((i=0; i<INPUT_VERBOSE; i++)); do COMMON_ARGS+=("-v"); done

        index_module() {
          local mod_dir="$1" mod_name="$2" output_file="$3"
          local args=("${COMMON_ARGS[@]}" "--output=$output_file" "--module-root=$mod_dir" "--module-name=$mod_name")
          [ -n "$INPUT_MODULE_VERSION" ] && args+=("--module-version=$INPUT_MODULE_VERSION")

          echo "Running: scip-go ${args[*]} ./..."
          if scip-go "${args[@]}" "./..." && [ -f "$output_file" ]; then
            echo "SCIP index generated: $output_file"
            return 0
          else
            echo "::error::Failed to index module: $mod_name"
            return 1
          fi
        }

        if [ "$INPUT_RECURSIVE" = "true" ]; then
          echo "Scanning for go.mod files..."
          INDEX_PATHS=()
          SUCCESS=0 FAILED=0
          RESULTS_FILE=$(mktemp)

          while IFS= read -r gomod; do
            mod_dir=$(dirname "$gomod")
            mod_name=$(grep -m1 '^module ' "$gomod" | awk '{print $2}')
            output_file="${mod_dir}/${INPUT_OUTPUT}"
            [ "$mod_dir" = "." ] && output_file="$INPUT_OUTPUT"

            echo "::group::Indexing: $mod_name ($mod_dir)"
            if index_module "$mod_dir" "$mod_name" "$output_file"; then
              INDEX_PATHS+=("${INPUT_PROJECT_ROOT}/${output_file}")
              echo "{\"path\":\"$mod_dir\",\"output\":\"$output_file\",\"module\":\"$mod_name\",\"status\":\"success\"}" >> "$RESULTS_FILE"
              SUCCESS=$((SUCCESS + 1))
            else
              echo "{\"path\":\"$mod_dir\",\"module\":\"$mod_name\",\"status\":\"index_failed\"}" >> "$RESULTS_FILE"
              FAILED=$((FAILED + 1))
            fi
            echo "::endgroup::"
          done < <(find . -name 'go.mod' -type f | sort)

          echo "Indexing complete: $SUCCESS succeeded, $FAILED failed"
          [ ${#INDEX_PATHS[@]} -eq 0 ] && echo "::error::No SCIP indexes generated" && exit 1

          {
            echo "index-path=$(IFS=','; echo "${INDEX_PATHS[*]}")"
            echo "results-file=$RESULTS_FILE"
          } >> "$GITHUB_OUTPUT"

          if [ "$FAILED" -gt 0 ] && [ "$SUCCESS" -eq 0 ]; then exit 1; fi
        else
          args=("${COMMON_ARGS[@]}" "--output=$INPUT_OUTPUT")
          [ -n "$INPUT_MODULE_ROOT" ] && args+=("--module-root=$INPUT_MODULE_ROOT")
          [ -n "$INPUT_MODULE_NAME" ] && args+=("--module-name=$INPUT_MODULE_NAME")
          [ -n "$INPUT_MODULE_VERSION" ] && args+=("--module-version=$INPUT_MODULE_VERSION")

          echo "Running: scip-go ${args[*]} ./..."
          scip-go "${args[@]}" "./..."

          [ ! -f "$INPUT_OUTPUT" ] && echo "::error::SCIP index not found: $INPUT_OUTPUT" && exit 1
          echo "index-path=${INPUT_PROJECT_ROOT}/${INPUT_OUTPUT}" >> "$GITHUB_OUTPUT"
        fi

    - name: Validate upload inputs
      if: inputs.upload == 'true'
      shell: bash
      env:
        SRC_ENDPOINT: ${{ inputs.sourcegraph-url }}
        SRC_ACCESS_TOKEN: ${{ inputs.sourcegraph-token }}
      run: |
        set -euo pipefail
        if [ -z "$SRC_ENDPOINT" ]; then
          echo "::error::sourcegraph_url is required when upload is enabled"
          exit 1
        fi
        if [ -z "$SRC_ACCESS_TOKEN" ]; then
          echo "::error::sourcegraph_token is required when upload is enabled"
          exit 1
        fi

    - name: Install src-cli
      if: inputs.upload == 'true'
      shell: bash
      env:
        SRC_CLI_VERSION: ${{ inputs.src-cli-version }}
      run: |
        set -euo pipefail
        mkdir -p "$HOME/.local/bin"

        case "$(uname -s)-$(uname -m)" in
          Linux-x86_64)  BINARY="src_linux_amd64" ;;
          Linux-aarch64) BINARY="src_linux_arm64" ;;
          Darwin-x86_64) BINARY="src_darwin_amd64" ;;
          Darwin-arm64)  BINARY="src_darwin_arm64" ;;
          *) echo "::error::Unsupported platform $(uname -s)-$(uname -m)"; exit 1 ;;
        esac

        if [ "$SRC_CLI_VERSION" = "latest" ]; then
          echo "Installing latest src-cli ($BINARY)..."
          echo "Warning: Checksum verification not available for 'latest' version"
          curl -fsSL "https://sourcegraph.com/.api/src-cli/$BINARY" -o "$HOME/.local/bin/src"
        else
          echo "Installing src-cli@${SRC_CLI_VERSION} ($BINARY)..."
          RELEASE_URL="https://github.com/sourcegraph/src-cli/releases/download/${SRC_CLI_VERSION}"
          curl -fsSL "${RELEASE_URL}/$BINARY" -o "$HOME/.local/bin/src"

          echo "Verifying checksum..."
          CHECKSUMS_FILE=$(mktemp)
          curl -fsSL "${RELEASE_URL}/src-cli_${SRC_CLI_VERSION}_checksums.txt" -o "$CHECKSUMS_FILE"

          EXPECTED_CHECKSUM=$(grep "  ${BINARY}\$" "$CHECKSUMS_FILE" | awk '{print $1}')
          if [ -z "$EXPECTED_CHECKSUM" ]; then
            echo "::error::Could not find checksum for $BINARY in checksums file"
            rm -f "$CHECKSUMS_FILE"
            exit 1
          fi

          if command -v sha256sum &> /dev/null; then
            ACTUAL_CHECKSUM=$(sha256sum "$HOME/.local/bin/src" | awk '{print $1}')
          else
            ACTUAL_CHECKSUM=$(shasum -a 256 "$HOME/.local/bin/src" | awk '{print $1}')
          fi

          if [ "$EXPECTED_CHECKSUM" != "$ACTUAL_CHECKSUM" ]; then
            echo "::error::Checksum verification failed. Expected: $EXPECTED_CHECKSUM, Actual: $ACTUAL_CHECKSUM"
            rm -f "$CHECKSUMS_FILE" "$HOME/.local/bin/src"
            exit 1
          fi

          echo "Checksum verified successfully"
          rm -f "$CHECKSUMS_FILE"
        fi
        chmod +x "$HOME/.local/bin/src"
        echo "$HOME/.local/bin" >> "$GITHUB_PATH"

    - name: Upload SCIP index
      if: inputs.upload == 'true'
      shell: bash
      working-directory: ${{ inputs.project-root }}
      env:
        SRC_ENDPOINT: ${{ inputs.sourcegraph-url }}
        SRC_ACCESS_TOKEN: ${{ inputs.sourcegraph-token }}
        INPUT_RECURSIVE: ${{ inputs.recursive }}
        INPUT_OUTPUT: ${{ inputs.output }}
        INPUT_REPOSITORY_REMOTE: ${{ inputs.repository-remote }}
        INPUT_PROJECT_ROOT: ${{ inputs.project-root }}
        INPUT_GITHUB_TOKEN: ${{ inputs.github-token }}
        RESULTS_FILE: ${{ steps.scip-go.outputs.results-file }}
      run: |
        set -euo pipefail

        # Mask secrets to prevent accidental exposure in logs
        if [ -n "$SRC_ACCESS_TOKEN" ]; then
          echo "::add-mask::$SRC_ACCESS_TOKEN"
        fi
        if [ -n "$INPUT_GITHUB_TOKEN" ]; then
          echo "::add-mask::$INPUT_GITHUB_TOKEN"
        fi

        # Validate URL to prevent credential exfiltration
        if [[ ! "$SRC_ENDPOINT" =~ ^https:// ]]; then
          echo "::error::sourcegraph_url must use HTTPS"
          exit 1
        fi
        if [[ "$SRC_ENDPOINT" =~ @ ]]; then
          echo "::error::sourcegraph_url must not contain embedded credentials"
          exit 1
        fi

        build_upload_args() {
          local file="$1"
          local root="$2"

          UPLOAD_ARGS=("-file=$file" "-no-progress" "-json")

          if [ -n "$GITHUB_SHA" ]; then
            UPLOAD_ARGS+=("-commit=$GITHUB_SHA")
          fi

          if [ -n "$INPUT_REPOSITORY_REMOTE" ]; then
            UPLOAD_ARGS+=("-repo=$INPUT_REPOSITORY_REMOTE")
          elif [ -n "$GITHUB_REPOSITORY" ]; then
            UPLOAD_ARGS+=("-repo=github.com/$GITHUB_REPOSITORY")
          fi

          if [ -n "$root" ] && [ "$root" != "." ]; then
            UPLOAD_ARGS+=("-root=$root")
          fi

          if [ -n "$INPUT_GITHUB_TOKEN" ]; then
            UPLOAD_ARGS+=("-github-token=$INPUT_GITHUB_TOKEN")
          fi
        }

        upload_single_index() {
          local file="$1"
          local root="$2"
          local module="$3"

          build_upload_args "$file" "$root"

          echo "Uploading: $file (root: ${root:-.})"

          { set +x; } 2>/dev/null || true
          if upload_output=$(src code-intel upload "${UPLOAD_ARGS[@]}" 2>&1); then
            echo "$upload_output"
            echo "success|$module|$root|$upload_output"
            return 0
          else
            echo "::error file=${file}::Upload failed for module: $module"
            echo "$upload_output"
            echo "failed|$module|$root|$upload_output"
            return 1
          fi
        }

        generate_summary() {
          local results_file="$1"
          local upload_success="$2"
          local upload_failed="$3"

          {
            echo "### SCIP Index Upload Summary"
            echo ""
            echo "**Results:** $upload_success succeeded, $upload_failed failed"
            echo ""
            echo "| Module | Root | Status | Details |"
            echo "|--------|------|--------|---------|"

            while IFS='|' read -r status module root output; do
              if [ "$status" = "success" ]; then
                upload_url=$(echo "$output" | jq -r '.uploadUrl // empty')
                if [ -n "$upload_url" ]; then
                  echo "| \`$module\` | \`${root:-.}\` | ✅ | [View upload]($upload_url) |"
                else
                  echo "| \`$module\` | \`${root:-.}\` | ✅ | Uploaded |"
                fi
              elif [ "$status" = "failed" ]; then
                echo "| \`$module\` | \`${root:-.}\` | ❌ | Upload failed |"
              elif [ "$status" = "index_failed" ]; then
                echo "| \`$module\` | \`${root:-.}\` | ⚠️ | Index failed (skipped) |"
              fi
            done < "$results_file"
          } >> "$GITHUB_STEP_SUMMARY"
        }

        if [ "$INPUT_RECURSIVE" = "true" ] && [ -n "$RESULTS_FILE" ] && [ -f "$RESULTS_FILE" ]; then
          echo "Uploading multiple SCIP indexes..."

          UPLOAD_RESULTS=$(mktemp)
          UPLOAD_SUCCESS=0
          UPLOAD_FAILED=0

          while IFS= read -r line; do
            status=$(echo "$line" | jq -r '.status')
            mod_path=$(echo "$line" | jq -r '.path')
            mod_name=$(echo "$line" | jq -r '.module')
            output_file=$(echo "$line" | jq -r '.output // empty')

            if [ "$status" = "success" ] && [ -n "$output_file" ]; then
              echo "::group::Uploading module: $mod_name"

              if [ "$mod_path" = "." ]; then
                root_path="$INPUT_PROJECT_ROOT"
              elif [ "$INPUT_PROJECT_ROOT" = "." ]; then
                root_path="$mod_path"
              else
                root_path="${INPUT_PROJECT_ROOT}/${mod_path}"
              fi
              [ "$root_path" = "." ] && root_path=""

              if result=$(upload_single_index "$output_file" "$root_path" "$mod_name"); then
                echo "$result" >> "$UPLOAD_RESULTS"
                UPLOAD_SUCCESS=$((UPLOAD_SUCCESS + 1))
              else
                echo "$result" >> "$UPLOAD_RESULTS"
                UPLOAD_FAILED=$((UPLOAD_FAILED + 1))
              fi

              echo "::endgroup::"
            else
              echo "index_failed|$mod_name|$mod_path|" >> "$UPLOAD_RESULTS"
            fi
          done < "$RESULTS_FILE"

          echo "Upload complete: $UPLOAD_SUCCESS succeeded, $UPLOAD_FAILED failed"

          generate_summary "$UPLOAD_RESULTS" "$UPLOAD_SUCCESS" "$UPLOAD_FAILED"

          rm -f "$UPLOAD_RESULTS" "$RESULTS_FILE"

          # Clear sensitive variables
          unset SRC_ACCESS_TOKEN INPUT_GITHUB_TOKEN

          if [ "$UPLOAD_FAILED" -gt 0 ] && [ "$UPLOAD_SUCCESS" -eq 0 ]; then
            echo "::error::All uploads failed"
            exit 1
          fi
        else
          build_upload_args "$INPUT_OUTPUT" "$INPUT_PROJECT_ROOT"

          echo "Uploading SCIP index to $SRC_ENDPOINT..."
          echo "Running: src code-intel upload -file=$INPUT_OUTPUT -no-progress [additional flags...]"

          { set +x; } 2>/dev/null || true
          upload_output=$(src code-intel upload "${UPLOAD_ARGS[@]}" 2>&1) || upload_status=$?
          upload_status=${upload_status:-0}

          # Clear sensitive variables
          unset SRC_ACCESS_TOKEN INPUT_GITHUB_TOKEN

          echo "$upload_output"

          if [ $upload_status -ne 0 ]; then
            echo "::error::Upload failed"
            exit $upload_status
          fi

          upload_repo=$(echo "$upload_output" | jq -r '.repo')
          upload_commit=$(echo "$upload_output" | jq -r '.commit')
          upload_root=$(echo "$upload_output" | jq -r '.root')
          upload_file=$(echo "$upload_output" | jq -r '.file')
          upload_indexer=$(echo "$upload_output" | jq -r '.indexer')
          upload_indexer_version=$(echo "$upload_output" | jq -r '.indexerVersion')
          upload_url=$(echo "$upload_output" | jq -r '.uploadUrl')

          {
            echo "### SCIP Index Upload"
            echo ""
            echo "| Property | Value |"
            echo "|----------|-------|"
            echo "| Repository | \`$upload_repo\` |"
            echo "| Commit | [\`${upload_commit:0:12}\`](${SRC_ENDPOINT}/${upload_repo}/-/commit/${upload_commit}) |"
            [ -n "$upload_root" ] && [ "$upload_root" != "null" ] && echo "| Root | \`$upload_root\` |"
            echo "| File | \`$upload_file\` |"
            echo "| Indexer | \`$upload_indexer\` |"
            echo "| Version | \`$upload_indexer_version\` |"
            echo ""
            echo "[View processing status]($upload_url)"
          } >> "$GITHUB_STEP_SUMMARY"

          echo "Upload complete"
        fi
